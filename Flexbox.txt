	Привет, хабр!	
	Одним прекрасным вечером, не предвещающим ничего интересного, 
в наш чатик поступило предложение от автора публикации «Переводим в код 5 действительно полезных шаблонов адаптивной разметки», 
написанной им весной 2012 года, написать статью-ремейк, но с применением FlexBox и сопутствующим пояснением что и как работает. 
После некоторой доли сомнений, интерес глубже разобраться в спецификации все таки победил и я благополучно сел верстать те самые примеры. 
В ходе погружения в эту область стало выясняться множество нюансов, что переросло в нечто большее чем просто переверстать макетики. 
В общем в данной статье хочу рассказать о такой чудесной спецификации, под названием «CSS Flexible Box Layout Module» и показать некоторые ее интересные особенности и примеры применения. 
Всех кому интересно, любезно приглашаю под хабракат.
	На что хотелось бы обратить внимание, для верстки лейаута на FlexBox, разработчику потребуется некоторая степень адаптации. 
На собственном примере почувствовал, что многолетний опыт играет злую шутку. 
FlexBox требует немного другого представления об выстраивании элементов в потоке.

	Техническая часть
	
	Во FlexBox есть два основных типа элементов: Гибкий Контейнер (Flex Container) и его дочерние элементы — Гибкие Элементы (Flex Item). 
Для инициализации контейнера достаточно присвоить, через css, элементу display: flex; или display: inline-flex;. 	
Разница между flex и inline-flex заключается лишь в принципе взаимодействия с окружающими контейнер элементами, подобно display: block; и display: inline-block;, соответственно. 
Внутри гибкого контейнера создаются две оси, главная ось (main-axis) и перпендикулярная или кросс ось (cross axis). 
Преимущественно гибкие элементы выстраиваются именно по главной оси, а потом уже по кросс оси. По умолчанию главная ось горизонтальная и имеет направление слева направо, 
а кросс ось вертикальна и направлена сверху вниз.
	Направлением осей можно управлять с помощью css-свойства 
flex-direction. 
	Данное свойство принимает ряд значений:
row (default): Главная ось гибкого контейнера имеет ту же ориентацию, как и инлайн ось текущего режима направления строк. 
	Начало (main-start) и конец (main-end) направления главной оси соответствуют началу (inline-start) и концу (inline-end) инлайн оси (inline-axis).
row-reverse: Все то же самое, что и в row только main-start и main-end меняются местами.
column: так же само как и row, только теперь главная ось направлена сверху вниз.
column-reverse: так же само как row-reverse, только главная ось направлена снизу вверх.
	Как это работает можно посмотреть в примере на jsfiddle http://jsfiddle.net/alexriz/Lrt66psw/.
	По умолчанию все гибкие элементы в контейнере укладываются в одну строку, даже если не помещаются в контейнер, они выходят за его границы. Данное поведение переключается с помощью свойства 
flex-wrap. 
	У этого свойства есть три состояния: 
nowrap (default): гибкие элементы выстраиваются в одну строку слева направо.
wrap: гибкие элементы строятся в многострочном режиме, перенос осуществляется по направлению кросс оси, сверху вниз.
wrap-reverse: так же как и wrap, но перенос происходит снизу вверх.
	Смотрим пример.
	Для удобства есть дополнительное свойство 
flex-flow, в котором можно одновременно указать flex-direction и flex-wrap. 
Выглядит это следующим образом: flex-flow: <flex-direction> <flex-wrap> 
Элементы в контейнере поддаются выравниванию при помощи свойства justify-content вдоль главной оси. 
	Это свойство принимает целых пять разных вариантов значений. 
flex-start (default): гибкие элементы выравниваются по началу главной оси.
flex-end: элементы выравниваются по концу главной оси
center: элементы выравниваются по центру главной оси
space-between: элементы занимают всю доступную ширину в контейнере, крайние элементы вплотную прижимаются к краям контейнера, а свободное пространство равномерно распределяется между элементами.
space-around: гибкие элементы выравниваются таким образом, что свободное пространство равномерно распределяется между элементами. Но стоит отметить, что пространство межу краем контейнера и крайними 
элементами будет в два раза меньше чем пространство между элементами в середине ряда. Конечно же поклацать пример работы этого свойства можно тут. Это еще не все, мы так же имеем возможность выравнивания элементов по кросс оси. 
	Применив свойство align-items, которое принимает также пять разных значений, можно добиться интересного поведения. Это свойство позволяет выравнивать элементы в строке относительно друг друга. 
flex-start: все элементы прижимаются к началу строки 
flex-end: элементы прижимаются к концу строки
center: элементы выравниваются по центру строки
baseline: элементы выравниваются по базовой линии текста
stretch (default): элементы растягиваются заполняя полностью строку.
	Еще одно похожее свойство на предыдущее это align-content. Только оно отвечает за выравнивание целых строк относительно гибкого контейнера. Оно не будет давать эффекта если гибкие элементы занимают одну строку. 
	Свойство принимает шесть разных значений.
flex-start: все линии прижимаются к началу кросс-оси
flex-end: все линии прижимаются к концу кросс-оси
center: Все линии паком выравниваются по центру кросс оси
space-between: линии распределяются от верхнего края до нижнего оставляя свободное пространство между строками, крайние же строки прижимаются к краям контейнера.
space-around: линии равномерно распределяются по контейнеру.
stretch (default): линии растягиваются занимая все доступное пространство.
	Попробовать как работают align-items и align-content можно в этом примере. Я специально два этих свойства представил в одном примере, так как они довольно плотно взаимодействуют каждый выполняя свою задачу. 
Обратите внимание что происходит когда элементы помещаются в одну строку и в несколько.
	С параметрами гибкого контейнера разобрались, осталось разобраться со свойствами гибких элементов.
Первое свойство с которым мы познакомимся это order. Это свойство позволяет менять позицию в потоке конкретному элементу. По умолчанию все гибкие элементы имеют order: 0; и строятся в порядке естественного потока. 
В примере можно увидеть как меняются местами элементы если к ним применять разные значения order.
Одно из основных свойств является flex-basis. С помощью этого свойства мы можем указывать базовую ширину гибкого элемента. По умолчанию имеет значение auto.
Это свойство тесно связано с flex-grow и flex-shrink, о которых я расскажу чуть позже. Принимает значение ширины в px, %, em и остальных единицах. 
По сути это не строго ширина гибкого элемента, это своего рода отправная точка. Относительно которой происходит растягивание или усадка элемента. 
В режиме auto элемент получает базовую ширину относительно контента внутри него. flex-grow на нескольких ресурсах имеет совершенно некорректное описание. 
Там говорится о том, что якобы оно задает соотношение размеров элементов в контейнере. На самом деле это не так. 
Это свойство задает фактор увеличения элемента при наличии свободного места в контейнере. о умолчанию это свойство имеет значение 0. Давайте представим, что у нас есть гибкий контейнер, который имеет ширину 500px, 
внутри него есть два гибких элемента, каждый из которых имеет базовую ширину 100px. Тем самым в контейнере остается еще 300px свободного места. Если первому элементу укажем flex-grow: 2;, 
а второму элементу укажем flex-grow: 1;. В результате эти блоки займут всю доступную ширину контейнера, только ширина первого блока будет 300px, а второго только 200px. Что же произошло? 
	А произошло вот что, доступные 300px свободного места в контейнере распределились между элементами в соотношении 2:1, +200px первому и +100px второму. Собственно так это и работает.
Тут мы плавно переходим к другому аналогичному свойству, а именно flex-shrink. По умолчанию имеет значение 1. Оно так же задает фактор на изменение ширины элементов, только в обратную сторону. 
Если контейнер имеет ширину меньше чем сумма базовой ширины элементов, то начинает действовать это свойство. Например контейнер имеет ширину 600px, 
а flex-basis элементов по 300px. Первому элементу укажем flex-shrink: 2;, а второму flex-shrink: 1;. Теперь сожмем контейнер на 300px. Следовательно сумма ширины элементов на 300px больше чем контейнер. 
Эта разница распределяется в соотношении 2:1, получается от первого блока отнимаем 200px, а от второго 100px. Новый размер элементов получается 100px и 200px, у первого и второго элемента, соответственно. 
Если мы устанавливаем flex-shrink в значение 0, то мы запрещаем сжиматься элементу до размеров меньше чем его базовая ширина.
На самом деле это очень упрощенное описание того как это все работает, дабы было понятен общий принцип. Более подробно, если кому интересно, алгоритм описан в спецификации.
Все три свойства можно записать в сокращенной форме при помощи выражения flex. Это имеет следующий вид:
flex: <flex-grow> <flex-shrink> <flex-basis>;
А так же мы можем писать еще два сокращенных варианта, flex: auto; и flex: none;, что означает flex: 1 1 auto; и flex: 0 0 auto; соответственно.
Последним свойством гибких элементов остался align-self. Тут все просто, это то же самое, что align-items у контейнера, позволяющее переопределять выравнивание для конкретно взятого элемента.

-----------------------------------------------------------------------------------------------------------------------
Comments:
-----------------------------------------------------------------------------------------------------------------------

 webschik  7 ноября 2014 в 11:25     
	Спасибо за статью! Очень полезно и понятно.
	Все время, как занимаюсь версткой, мечтал о таком :)
	В принципе можно использовать и на боевых проектах, не только для «поиграться» — caniuse показывает 88.45%

-----------------------------------------------------------------------------------------------------------------------
	
	Строго говоря — 76.33%. Partial support (12.12%) — это в основной массе старая спецификация, та, 
	которая про display: flexbox.

---------------------------------------------------------------------------------------------------
 
 spmbt  8 ноября 2014 в 03:48  
	В статье ничего не сказано, что с ним приходится тщательно подгонять кроссбраузерность, 
	смотреть в ИЕ10 и 11, при этом 10-й сильно отличается, и кое-что на нём просто не сделаешь. 
	В остальном всё отлично.

---------------------------------------------------------------------------------------------------

	Скажем, не прям уж так тщательно, флексбокс поддерживается в полной мере всеми современными десктопными и 
	мобильными браузерами, кроме OperaMini. Да ок, для Safari, iOS Safari и BB нужен, пока что, префикс. 
	Статья не совсем об этом. А люди ведь умные все, так же как, и вы, и я знают где можно посмотреть 
	насколько поддерживается та или иная технология, правда :)
	Возможно я и ошибаюсь, конечно, но по моему, об caniuse столько раз говорили, что лишний раз повторяться 
	не имеет смысла, наверное :)
	А что касается багов, внезапно, но в IE11 поведение флексбокс самое корректное. Есть один общий баг в 
	Chrome и Firefox, можно посмотреть в этом фиддле (в IE11 работает правильно, текст не вылазит за границы 
	серого блока при уменьшении ширины контейнера). И еще один баг лично в Firefox связанный с работой 
	shrink: 0; и basis: auto; можно глянуть пример тут (в Chrome и IE11 правильно).
	Но я посчитал, что это настолько уникальные ситуации, что акцентировать на этом внимание в статье не стоит. 
	Может быть я не прав. В ходе экспериментов больше багов я не обнаружил. Если вы знаете какие-то еще 
	интересные баги, я буду рад если вы поделитесь своими ценными знаниями :)
	По поводу IE10 и прочих старых браузеров, у меня есть идея, которая, по моему скромному мнению, 
	должна всем понравиться, но не все ее поддержат, скорее всего. Давайте все вместе стремиться 
	поддерживать только современные браузеры, я понимаю, что это не всегда возможно, но хотя бы стоит 
	пытаться. Я уверен, что постепенно все получится. Господа разработчики IE действительно очень 
	постарались, чтобы их браузер не портил нам настроение, или хотя бы минимально. Я считаю, что у них 
	это вполне получается. 
	Теперь даже шутки над IE стали неактуальны совсем :)
